{
  "name": "coffee-coverage",
  "description": "JSCoverage-style instrumentation for CoffeeScript files.",
  "keywords": [
    "javascript",
    "coffeescript",
    "coverage",
    "code coverage",
    "test"
  ],
  "version": "0.3.0",
  "author": {
    "name": "Benbria",
    "url": "http://www.benbria.com/"
  },
  "contributors": [
    {
      "name": "Jason Walton",
      "email": "dev@lucid.thedreaming.org",
      "url": "https://github.com/jwalton"
    },
    {
      "name": "Drew Stokes",
      "email": "drew@drewstokes.com",
      "url": "https://github.com/dstokes"
    },
    {
      "name": "Vyacheslav Slinko",
      "email": "vyacheslav.slinko@gmail.com",
      "url": "https://github.com/vslinko"
    },
    {
      "name": "David Dahl",
      "url": "https://github.com/effata"
    }
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/benbria/coffee-coverage/master/LICENSE"
    }
  ],
  "main": "./lib/coffeeCoverage",
  "bin": {
    "coffeeCoverage": "./bin/coffeecoverage"
  },
  "directories": {
    "lib": "./lib"
  },
  "dependencies": {
    "coffee-script": ">=1.6.2",
    "pkginfo": ">=0.2.3",
    "argparse": ">=0.1.7"
  },
  "engines": {
    "node": ">=0.6.19"
  },
  "readme": "Benbria CoffeeCoverage\n======================\n\nCompiles .coffee files to .js files, and adds [JSCoverage](http://siliconforks.com/jscoverage/)\nstyle instrumnetation for the original coffee script source.\n\nContents\n--------\n\n*   [Installation and a Quick Intro](#installation-and-a-quick-intro)\n*   [What it Does](#what-it-does)\n*   [How it Works](#how-it-works)\n*   [Using with Mocha and Node.js](#using-with-mocha-and-nodejs)\n*   [Some Weirdness with Line Numbers](#some-weirdness-with-line-numbers)\n*   [Detailed Usage](#detailed-usage)\n\n\nWhat it Does\n------------\n\nBenbria CoffeeCoverage takes a collection of .coffee files, and produces .js files which have been\ninstrumented to record how many times each line is executed.  Given a file \"hello.coffee\":\n\n    console.log \"Hello World\"\n\nIt produces output that looks something like this (edited slightly for brevity and readability):\n\n    // coffeeCoverage generated initialization\n    if (! _$jscoverage[\"hello.coffee\"]) {\n        _$jscoverage[\"hello.coffee\"] = [];\n        _$jscoverage[\"hello.coffee\"][1] = 0;\n    }\n    _$jscoverage[\"hello.coffee\"].source = [\"console.log \\\"Hello World\\\"\", \"\"];\n\n    (function() {\n\n      _$jscoverage[\"hello.coffee\"][1]++; // Count that we're executing line #1\n      console.log(\"Hello World\");\n\n    }).call(this);\n\nThe output is intentionally similar to that of [JSCoverage](http://siliconforks.com/jscoverage/),\nso that your source can be used with existing coverage-analysis tools.\n\n\nInstallation and a Quick Intro\n------------------------------\n\nInstall with:\n\n    npm install -g coffee-coverage\n\nGiven a directory \"source\" full of .coffee files, run:\n\n    coffeeCoverage ./source ./dest\n\nThis will recursively find all the .coffee files in the \"source\" directory, and produce .js files\nin the \"dest\" directory.  Note that you can compile in-place with:\n\n    coffeeCoverage ./source ./source\n\n\nHow it Works\n------------\nSee the [Design](https://github.com/benbria/coffee-coverage/wiki/Design) page on the Wiki.\n\n\nUsing with Mocha and Node.js\n----------------------------\n\n### Dynamic Compilation\n\nThere are two ways to use coffeeCoverage as part of your unit tests.  First, if you run your\ntests directly on your .coffee files, you can register coffeeCoverage to dynamically compile\n.coffee (and even ._coffee if you're using [streamlinejs](https://github.com/Sage/streamlinejs))\nfiles.  For example, create a \"register-handlers.js\":\n\n    # If you're using with streamline, you *must* register streamline first:\n    require('streamline').register({});\n\n    #  Register coffee-coverage if coverage is enabled.\n    if(process.env.COVERAGE) {\n        require('coffee-coverage').register({\n            path: 'abbr',\n            basePath: __dirname,\n            exclude: ['/test', '/node_modules', '/.git'],\n            initAll: true,\n            streamlinejs: true\n        });\n    }\n\nNote we set the \"basePath\" to the root of our project.  This can be a path which is relative to\n`__dirname` (e.g. `__dirname + \"/..\"`).\n\nNote that streamline support is \"experimental\" right now (i.e. it might break at any moment\nbecause we're using undocumented features in streamlinejs) so to turn it on, you have to\nexplicitly pass 'streamlinejs: true' as an option.\n\nThen, run your tests:\n\n    COVERAGE=true mocha --require register-handlers.js --reporter html-cov ...\n\n### Static Compilation\n\nAlternatively, you can use coffeeCoverage to statically compile your code with instrumentation:\n\n    # Compile everything except the test directory with coffeeCoverage\n    coffeeCoverage --initfile ./lib/init.js --exclude test --path abbr ./src ./lib\n    # Compile the test directory with regular coffee-script\n    coffee -o ./lib/test ./src/test\n\nThis also writes an \"lib/init.js\" which initializes all the execution counts to 0.  This is handy,\nbecause otherwise if we never `require` a given module, that module's counts won't show up at all\nin the code coverage report, which might overly inflate our code coverage percentage.  Next we run\nour tests:\n\n    mocha --require ./lib/init.js --reporter html-cov ./lib/test/*\n\nStatic compilation does not currently support streamline.\n\nSome Weirdness with Line Numbers\n--------------------------------\n\nThis snippet of CoffeeScript:\n\n    if x then y() \\\n         else z()\n\ngets compile to this snippet of JavaScript:\n\n    if (x) {\n      y();\n    } else {\n      z();\n    }\n\nWe have three statements we could annotate here; the \"if\" itself, the call to y, and the call to z.\nThe problem is that both the \"if\" an the call to \"y()\" are on the same line of CoffeeScript source.\nIf we annotate both the \"if\" and the \"y()\", then if `x` is true, we will count two executions of the\nfirst line of the CoffeeScript, even though we've only run this chunk of CoffeeScript once.\n\nCoffeeCoverage tries to work around this by only instrumenting the first statement it finds on a\nline, so in the above example, we'd annotate the \"if\" and the \"z()\", but not the \"y()\".\n\nAlso, it's worth noting a minor difference in the way coffee-coverage compiles statements.  The\nfollowing coffee code:\n\n    if x\n      a()\n    else if y\n      b()\n\nWould normally compile to:\n\n    if(x) {\n      a();\n    } else if(y) {\n      b();\n    }\n\ncoffeeCoverage will instead compile this to:\n\n    if(x) {\n      a();\n    } else {\n      if(y) {\n        b();\n      }\n    }\n\nbecause otherwise it would be unable to annotate the `if(y)` statement.\n\nDetailed Usage\n--------------\n\nUsage: `coffeeCoverage [-h] [-v] [-c name] [-e filenames] [-i initfile] [--path pathtype] src dest`\n\n`src` and `dest` are the source file or directory and destination file or directory, respectively.\nIf `src` is a .coffee file, then coffeecoverage will instrument the file and write the result to\n`dest` (e.g. `coffeeCoverage a.coffee a.js`.)  If `src` is a directory, then coffeecoverage will\nrecursively walk through `src` finding .coffee files, and writing them into the `dest`, creating\nany subdirectories in `dest` as required.  If `src` and `dest` are the same directory, then all the\n.coffee files in `src` will have .js files written alongside them.\n\n### Optional arguments:\n\n#### -c, --coverageVar\n\nBy default, coffeecoverage will instrument source files with the global variable \"_$jscoverage\".\nThis is done to mimic JSCoverage.  You can rename this variable by using this option.\n\n#### -i, --initfile\n\nSpecifies an \"initfile\" which all global initalization is written to.  This is handy for testing\nwith mocha.  If you `require` the initfile, then mocha reports will show coverage of all files in\nyour project, even files which were never required anywhere.\n\n#### -e, --exclude\n\nGives a comma delimited list of files and directories to exclude from processing.  This defaults\nto 'node_modules,.git', since neither of these are directories you probably want to be\ninstrumenting.  If you want to also exclude your \"test\" directory, you might run coffeeCoverage\nwith:\n\n    coffeeCoverage --exclude 'node_modules,.git,test' ...\n\n#### --path\n\nPath can be given one of three different parameters:\n\n - `none` is the default - if coffeeCoverage reads a file from \"src/models/user.coffee\", then\n   the instrumented code will use the filename \"user.coffee\".  This works well provided you\n   don't reuse filenames elsewhere in your code.  Note that if there is a name collision between\n   two files in different subdirectories, coffeecoverage will append a something to the\n   end of one to make it unique, otherwise coverage data from one file would interfere with data\n   from another.\n - `abbr` will use abbreviated path names; a file from \"src/models/user.coffee\" will be\n   instrumented as \"s/m/user.coffee\".\n - `relative` will use the full relative pathname; \"src/models/user.coffee\".\n\nPaths are always relative to the `src` directory provided on the command line.\n",
  "readmeFilename": "README.md",
  "_id": "coffee-coverage@0.3.0",
  "_from": "coffee-coverage@"
}
